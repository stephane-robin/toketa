{% extends '../../../modelePage.html' %}
{% load static %}

{% block contenu %} 
<ul>
  <li><a href="#systeme">comprendre le rôle d'un système d'exploitation</a></li>
  <li><a href="#principaux">connaître les principaux systèmes d'exploitation</a></li>
  <li><a href="#linux">connaître l'architecture Linux</a></li>
  <li><a href="#bash">savoir utiliser les principales lignes de commande</a></li>
  <li><a href="#fichier">savoir afficher un fichier au terminal</a></li>
  <li><a href="">la documentation</a></li>
  <li><a href="">les droits d'utilisateur</a></li>
  <li><a href="">l'installation d'un programme, la décompression d'une archive</a></li>
  <li><a href="">la sécurité sur Linux</a></li>
  <li><a href="">la mise à niveau système</a></li>
  <li><a href="">la création d'une clé bootable et l'installation de Linux</a></li>
</ul>
{% endblock contenu %}

{% block cours %}

<!-- ROLE D'UN SYSTEME D'EXPLOITATION -->
<p class="invisible" id="systeme">ancre</p>

<h3>Rôle d'un système d'exploitation</h3>

<p>Le rôle d'un système d'exploitation est le suivant :
	<ul>
		<li>communication avec les périphériques (processeur, mémoire, carte graphique, carte réseau, clavier, écran, ...)</li>
		<li>exécution des programmes</li>
		<li>gestion des tâches</li>
		<li>gestion d'accès aux ressources</li>
	</ul>
</p>

<p>Tout système d'exploitation est construit autour de son noyau, qui communique directement avec les différents périphériques par l'intermédiaire d'un logiciel appelé pilote, ou qui utilise pour accéder aux ressources des intermédiaires appelés gestionnaires de ressources.</p>

<p>Une ressource peut être par exemple un processeur, une variable stockée en mémoire, une imprimante, ...</p>


<!-- PRINCIPAUX SYSTEMES D'EXPLOITATION -->
<p class="invisible" id="principaux">ancre</p>

<h3>Les principaux systèmes d'exploitation</h3>

<p>Les systèmes d'exploitation les plus répandus sont les suivants : Windows, Android, iOS, MacOS, Linux et Unix.</p>
<p>On peut les classer en deux catégories : le système Windows et les systèmes posix.</p>

<p>Windows est issu de MS-DOS alors que les systèmes posix sont un ensemble de normes techniques définissant les 
  interfaces communes à tous les systèmes issus de Unix, tels que Linux, MacOS, Android, iOS, ... Windows est particulièrement 
utilisé dans le monde du jeu vidéo et dispose de normes, frameworks et langages tels que ASP.net, C#, ...</p>

<p>Nous étudierons tout particulièrement la famille de systèmes d'exploitation GNU/Linux inventée par Linus Torvalds en 1991.
  Il s'agit de systèmes d'exploitation open source de type Unix, essentiellement utilisé dans les serveurs et par les professionnels 
  travaillant comme développeurs d'applications. De nombreuses distributions ont vu le jour dont notamment Debian et Ubuntu. 
Le noyau Linux est issu du projet GNU créé en 1984 par Richard Stallman, maintenu par une communauté de hackers et soutenu 
par la Free Software Foundation. La philosophie du projet GNU s'inscrit dans un démarche sociale favorisant le mouvement 
du logiciel libre.</p>

<p>Les systèmes d'exploitations Linux sont souvent critiqués car ils sont gratuits et leur mise en oeuvre est moins intuitive 
  que celle d'autres systèmes. Pourtant, ils sont très fiables et extrêmement puissants.</p>


<!-- ARCHITECTURE LINUX -->
<p class="invisible" id="linux">ancre</p>

<h3>Architecture Linux</h3>

<h4>Arborescence</h4>

  <p>La racine est symbolisée par / en Linux.</p>

  <ul>
    <li>bin contient les fichiers exécutables de la machine,</li>
    <li>dev contient les périphériques,</li>
    <li>etc contient les fichiers de configuration,</li>
    <li>home contient les répertoires personnels de chaque utilisateur (d'où le nom de dossier home/stephane),</li>
    <li>lib contient les bibliothèques partagées par les programmes,</li>
    <li>media est un répertoire de montage pour les périphériques amovibles,</li>
    <li>opt est utilisé pour les extensions de programmes,</li>
    <li>root est le dossier dédié au superutilisateur,</li>
    <li>sbin contient les programmes système importants,</li>
    <li>tmp est utilisé par les programmes pour stocker des fichiers,</li>
    <li>proc contient les informations du système,</li>
    <li>usr est le dossier dans lequel seront stockés les programmes installés par l'utilisateur</li>
    <li>site-packages est le dossier dans lequel seront stockés les packages</li>
    <li>var contient les logs</li>
  </ul>

<p>Un point "." devant le nom d'un fichier ou d'un dossier indique qu'il est caché lors de l'affichage. Il n'est pas pour autant introuvable,
Linux a souhaité le cacher pour ne pas encombrer l'affichage. En revanche un point "." devant une adresse représente le dossier courant,
alors qu'un point double point ".." devant une adresse représente le dossier parent. Le signe ~ symbolise le dossier personnel /home/[nomUtilisateur] où [nomUtilisateur] est 
le nom de l'utilisateur tel qu'il a été défini par la machine lors de la configuration du système.</p>



  <p>L'installation d'applications sous Linux ne nécessite pas de programme d'installation comme sous Windows, mais des paquets au format .deb qui
  contiennent à la fois les instructions d'installation et l'application elle-même. Les fichiers .deb se trouvent dans des dépôts
  et la gestion des dépendances est automatisée. Les fichiers .deb sont des versions compilées de programmes, donc sous forme binaire. Ils se basent sur les codes sources
  des programmes qui sont écrits dans le langage dans lequel ils ont été créés (Python, C, Java, ...).</p>



  <h4>L'invite de commande</h4>

  <p>Par défaut, le Terminal s'ouvre dans le dossier /home/[nomUtilisateur]. Une fois le Terminal ouvert, le signe $ symbolise l'utilisateur alors que le signe # symbolise le superutilisateur qui travaille 
  en mode root. On voit donc apparaître à l'ouverture du Terminal une invite de commande de la forme :</p>
  
  <pre><code class="language-svg">[nomUtilisateur]@[nomOrdinateur]:~$</code></pre>

  <p>Le superutilisateur est en fait l'administrateur de la machine et dispose de tous les droits sur son système. 
Pour exercer ses droits, le superutilisateur précède chacune des instructions ayant un impact sur le système d'exploitation par la commande sudo qui nécessaire la saisie 
du mot de passe administrateur, comme dans l'exemple ci-dessous :</p>

<pre><code class="language-svg">sudo apt-get install python</code></pre>

  <p>L'autocomplétion se réalise avec la touche de tabulation, la navigation dans le terminal se fait à l'aide des flèches haut et bas.</p>

  <p>Une double tabulation permet d'afficher toutes commandes dont le nom commence par les lettres écrites
  dans la console. Par exemple lorsqu'on tape da puis deux fois la touche tabulation, on obtient les choix
  dash et date.</p>

  <p><em>clear</em> ou Ctrl+l permet d'effacer le contenu de la console.</p>

  <p><em>exit</em> ou Ctrl+d permet de fermer la console</p>


  <p>Le .bashrc est un fichier de configuration du Terminal. Il se situe dans le répertoire personnel /home/[nomUtilisateur]/</p>

  


  <!-- LIGNES DE COMMANDE -->
  <p class="invisible" id="bash">ancre</p>

  <h3>Les principales lignes de commande</h3>

  <h4>Commandes générales</h4>

  <table>
    <tr> <th> Objectif</th> <th> Instruction</th> </tr>
    <tr> <td> afficher le dossier courant (print working directory)</td><td><pre><code class="language-svg">pwd</code></pre></td></tr>
    <tr> <td> se rendre dans le dossier <em>Documents</em> </td> <td> <pre><code class="language-svg">cd Documents</code></pre> </td> </tr>
    <tr> <td> revenir au dossier parent </td> <td> <pre><code class="language-svg">cd ..</code></pre></td> </tr>
    <tr> <td> revenir à /home/stephane </td> <td> <pre><code class="language-svg">cd</code></pre></td> </tr>
    <tr> <td> afficher la date </td> <td> <pre><code class="language-svg">date</code></pre></td></tr>
    <tr> <td> connaître la version du système Linux</td> <td><pre><code class="language-svg">lsb_release -a</code></pre></td></tr>
    <tr> <td> connaître la taille du dossier courant (uniquement) en utilisant une lecture facile pour l'homme</td> <td><pre><code class="language-svg">du -sh</code></pre></td></tr>
    <tr> <td> stopper l'exécution d'un code ou d'un serveur </td><td><pre><code class="language-svg">Ctrl+c</code></pre></td></tr>
    <tr> <td> quitter une interface exécutée à partir du terminal </td> <td><pre><code class="language-svg">q</code></pre></td></tr>
    <tr> <td> vider le terminal</td> <td><pre><code class="language-svg">clear</code></pre></td> </tr>
  </table>


  <h4>Lister, afficher</h4>

  <table>
    <tr> <th> Objectif</th> <th> Instruction</th> </tr>
    <tr> <td> afficher la liste des éléments du dossier courant </td> <td> <pre><code class="language-svg">ls</pre></td> </tr>
    <tr> <td> afficher la liste détaillée des éléments du dossier courant </td> <td> <pre><code class="language-svg">ls -l</code></pre></td> </tr>
    <tr> <td> afficher la liste détaillée des éléments du dossier courant avec une taille facilement lisible pour
      l'homme</td> <td><pre><code class="language-svg">ls -lh</code></pre></td></tr>
    <tr> <td> afficher la liste des éléments du dossier courant avec les éléments cachés </td> <td> <pre><code class="language-svg">ls -a</code></pre></td> </tr>
    <tr> <td> afficher la liste détaillée des éléments du dossier courant avec les éléments cachés </td> <td> <pre><code class="language-svg">ls -la</code></pre></td> </tr>
    <tr> <td> afficher la liste détaillée des éléments du dossier courant en triant par date de dernière modification au lieu de trier par ordre alphabétique</td> <td><pre><code class="language-svg">ls -lt</code></pre></td></tr>
    <tr> <td> afficher la liste des éléments de MonDossier à partir de son adresse absolue</td> <td><pre><code class="language-svg">ls ~/Documents/MonDossier</code></pre></td></tr>
    <tr> <td> afficher la liste des éléments actifs du dossier local </td> <td> <pre><code class="language-svg">ps</code></pre></td> </tr>
    <tr> <td> afficher le contenu de <em>monFichier</em> (voir détails plus bas)</td> <td> <pre><code class="language-svg">cat monFichier</code></pre></td> </tr>
  </table>

  <h4>Créer, copier, déplacer, supprimer</h4>

  <p>Attention, il n'y a pas de possibilité de récupération d'un dossier ou fichier supprimé à l'aide de la commande rm. Il n'y a
  donc pas d'équivalent d'une corbeille lorsqu'on utilise les lignes de commande. Il n'y a pas non plus de demande de confirmation, le dossier ou fichier
  est simplement supprimé au moment oû l'utilisateur presse la touche Entrée, à moins d'utiliser l'option -i. La commande rm est donc à utiliser avec précaution,
    et il semble important d'utiliser systématiquement l'option -i.</p>

  <table>
    <tr> <th> Objectif</th> <th> Instruction</th> </tr>
    <tr> <td> créer le fichier <em>monFichier</em> </td> <td> <pre><code class="language-svg">touch monFichier</code></pre></td> </tr>
    <tr> <td> créer le dossier <em>monDossier</em> </td> <td> <pre><code class="language-svg">mkdir monDossier</code></pre></td> </tr>
    <tr> <td> creer le dossier <em>monDossier</em> contenant le sous-dossier <em>monSousDossier</em></td> <td><pre><code class="language-svg">mkdir -p monDossier/monSousDossier</code></pre></td></tr>
    <tr> <td> supprimer <em>monFichier</em> </td> <td><pre><code class="language-svg">sudo rm monFichier</pre></td></tr>
    <tr> <td> supprimer <em>monFichier</em> en demandant confirmation (-i) et en demandant l'état de ce qui a été fait (-v)</td> <td><pre><code class="language-svg">sudo rm -vi monFichier</code></pre></td></tr>
    <tr> <td> supprimer <em>monDossier</em> et tout ce qu'il contient</td> <td><pre><code class="language-svg">sudo rm -r monDossier</code></pre></td></tr>
    <tr> <td> déplacer <em>monFichier</em></td> <td><pre><code class="language-svg">mv chemin_monFichier  chemin_nouvelEmplacement</code></pre></td></tr>
    <tr> <td>copier monFichier dans le répertoire courant</td> <td><pre><code class="language-svg">cp monFichier monFichierCopie</code></pre></td></tr>
    <tr> <td>copier monFichier dans Documents</td> <td><pre><code class="language-svg">cp monFichier ~/Documents/monFichierCopie</code></pre></td></tr>
    <tr> <td>copier monFichier dans Documents sous le même nom</td> <td><pre><code class="language-svg">cp monFichier ~/Documents/</code></pre></td></tr>
    <tr> <td> copier tous les fichiers au format .py dans monDossier</td> <td><pre><code class="language-svg">cp *.py monDossier/</code></pre></td></tr>
    <tr> <td> copier monDossier et tout ce qu'il contient</td> <td><pre><code class="language-svg">cp -R monDossier monDossierCopie</code></pre></td></tr>
    <tr> <td> déplacer monFichier dans monDossier</td> <td><pre><code class="language-svg">mv monFichier monDossier/</code></pre></td></tr>
    <tr> <td> déplacer monDossier et tout ce qu'il contient dans monAutreDossier</td> <td><pre><code class="language-svg">mv monDossier/ monAutreDossier/</code></pre></td></tr>
    <tr> <td> déplacer tous les fichiers au format .py dans monDossier</td> <td><pre><code class="language-svg">mv *.py monDossier/</code></pre></td></tr>
    <tr> <td> renommer monFichier en nouveauNomFichier</td> <td><pre><code class="language-svg">mv monFichier nouveauNomFichier</code></pre></td></tr>
    <tr> <td> déplacer monFichier dans monDossier et le renommer nouveauNomFichier</td> <td><pre><code class="language-svg">mv monFichier monDossier/nouveauNomFichier</code></pre></td></tr>
  </table>



  <h4>Commandes liées à Python</h4>

  <table>
    <tr> <th> Objectif</th> <th> Instruction</th> </tr>
    <tr> <td> connaître l'emplacement d'un programme (par exemple Python)</td> <td><pre><code class="language-svg">which python3</code></pre></td></tr>
    <tr> <td> connaître la version d'un programme (par exemple Python)</td> <td><pre><code class="language-svg">python3 --version</code></pre></td></tr>
    <tr> <td> lancer l'interpréteur Python </td> <td><pre><code class="language-svg">python3</code></pre></td></tr>
    <tr> <td> exécuter monFichier.py en utilisant Python</td> <td><pre><code class="language-svg">python3 monFichier.py</code></pre></td></tr>
    <tr> <td> quitter l'interpréteur Python </td> <td><pre><code class="language-svg">exit()</code></pre></td></tr>
    <tr> <td> installer un package Python </td> <td><pre><code class="language-svg">pip install monPackage</code></pre></td></tr>
    <tr> <td> désinstaller un package Python </td> <td><pre><code class="language-svg">pip uninstall monPackage</code></pre></td></tr>
    <tr> <td> exécuter monPackage en Python </td> <td><pre><code class="language-svg">python3 -m monPackage</code></pre></td></tr>
  </table>


<!-- AFFICHAGE D'UN FICHIER AU TERMINAL -->
<p class="invisible" id="fichier">ancre</p>

<h3>Affichage d'un fichier au Terminal</h3>

  <p>Pour afficher un fichier tout entier dans la console, on se place dans le dossier parent du fichier à lire puis on utilise l'instruction</p>
  <pre><code class="language-svg">cat nomFichier</code></pre>

  <p>Si l'on souhaite afficher également le numéro de chaque ligne du fichier il faut rajouter</p>
  <pre><code class="language-svg">cat nomFichier -n</code></pre>

  <p>Si l'on souhaite afficher le fichier page par page, on utilise l'instruction</p>
  <pre><code class="language-svg">less nomFichier</code></pre>

  <p>Dans ce cas, la console ne fonctionne plus qu'en mode affichage.</p>
  <ul>
    <li>pour revenir en mode normal, il faut taper 'q'</li>
    <li>pour descendre d'une ligne, on peut utiliser la flèche du bas</li>
    <li>pour monter d'une ligne, on peut utiliser la flèche du haut</li>
    <li>pour descendre en bas de l'ếcran, on peut utiliser la touche Entrée ou la touche Page Down</li>
    <li>pour monter en haut de l'écran, on peut utiliser la touche PageUp</li>
    <li>pour rechercher unMot dans le fichier lu dans la console, on peut utiliser /unMot directement</li>
  </ul>

  <p>Pour afficher les 5 premières lignes de monFichier</p>
  <pre><code class="language-svg">head -n 5 monFichier</code></pre>

  <p><em>Attention</em> toutefois, le terminal n'est en mesure de lire que des formats simples tels que .TXT, .HTML, .JSON, etc... ou des formats de 
  langage de programmation tels que .C, .PY, .JAVA, .JS, etc ... Ainsi le format .ODT de LibreOffice n'est pas lu correctement, 
de même que les formats propriétaires comme .DOCX, .XLSX, etc ...</p>



<h4>Utilisation de nano</h4>

<p>Il est également possible de lire un fichier au Terminal en utilisant un éditeur de texte minimaliste appelé nano, 
  présent par défaut dans les systèmes Linux.</p>

<p>Pour connaître la version de nano prise en charge par ton système d'exploitation Linux, exécute au Terminal l'instruction suivante :</p>
<pre><code class="language-svg">nano --version</code></pre>

<p>Pour installer nano sur les machines Debian ou Ubuntu, exécute la commande suivante au Terminal :</p>
<pre><code class="language-svg">sudo apt-get install nano</code></pre>

<p>Ensuite, pour ouvrir le fichier monFichier.txt avec nano, il suffit de se rendre dans le dossier contenant monFichier.txt et d'exécuter au Terminal l'instruction :</p>
<pre><code class="language-svg">nano monFichier.txt</code></pre>

<p>ou alors, rester dans le dossier courant et indiquer l'adresse absolue de monFichier.txt comme dans l'exemple ci-dessous :</p>
<pre><code class="language-svg">nano ~/Documents/monFichier.txt</code></pre>

<p>Une fois le fichier ouvert avec nano, il est possible de naviger à l'aide des flèches, de modifier le contenu du 
  fichier puis d'enregistrer les modifications à l'aide des touches Ctrl+O ou Ctrl+S. Pour quitter nano, il faut appuyer sur les 
  touches Ctrl+X.</p>





  <h3>RTFM</h3>

  <p> Pour afficher la documentation relative à la commande mkdir dans la console, on utilise </p>
  <pre><code class="language-svg">man mkdir</code></pre>

  <p>La documentation contient les éléments suivants :</p>
  <ul>
    <li>NAME : le nom de la commande</li>
    <li>SYNOPSIS : les différentes formes d'utilisation de la commande</li>
    <li>DESCRIPTION : détail des différentes options possibles et explications des fonctionnalités</li>
    <li>AUTHOR : auteurs de la documentation et de la commande</li>
    <li>REPORTING BUGS : adresses pour reporter un bug</li>
    <li>COPYRIGHT : licence d'utilisation</li>
    <li>SEE ALSO : autres commandes pouvant être utiles</li>
  </ul>




  <!-- DROITS UTILISATEUR -->

  <h3>Les droits d'utilisateur</h3>

  <p>La commande <em>sudo</em> permet de passer temporairement en mode root et d'acquérir les droits du super-utilisateur. Elle signifie
    Substitute User DO. Une fois en mode root, l'invite de commande se termine par le symbole # .</p>
  <p>Contrairement à Windows, le système Linux n'est pas connecté par défaut en mode root, ce qui limite les risques potentiels.</p>



  <h4>Changement de mot de passe</h4>

  <p>Pour changer le mot de passe du compte [nomUtilisateur] :</p>

  <pre><code class="language-svg">sudo passwd [nomUtilisateur]</code></pre>

  <p>Pour changer le mot de passe du compte sur lequel on est connecté, c'est à dire du super-utilisateur et de la connexion à la machine.</p>

  <pre><code class="language-svg">sudo passwd</code></pre>


  <h4>Modification des droits d'accès</h4>

  <p>Chaque dossier et chaque fichier possède une liste de droits symbolisés par une lettre :</p>
  <ul>
    <li>d pour directory : indique si l'élément est un dossier</li>
    <li>l pour link : indique si l'élément est un lien ou un raccourci vers un fichier ou dossier</li>
    <li>r pour read : indique si on peut lire l'élément</li>
    <li>w pour write : indique si on peut modifier l'élément et donc le supprimer</li>
    <li>x pour execute : indique si on peut exécuter cet élément lorsque c'est un fichier, indique si on
      peut voir les sous-dosssiers qu'il contient lorsqu'on a le droit de lecture dessus</li>
  </ul>

  <p>On peut consulter ces droits avec la commande ls -l. Lorsqu'ils existent les droits sont symbolisés par une lettre,
    lorsqu'ils n'existent pas les droits sont remplacés par un tiret. Par ailleurs, les droits sont regroupés de la façon suivante et
    sans espace : (dossier) (utilisateur proprétaire) (groupe) (autres utilisateurs)</p>
    <p>Par exemple on peut trouver les information suivantes lorsqu'on utilise la commande ls -l</p>

  <pre><code class="language-svg">drwxr-xr-x 1 [nomUtilisateur] [nomUtilisateur] 4096 2020-11-03 21:37 Desktop</code></pre>

  <p>Lorsqu'un dossier autorise tous les droits, on obtient donc l'information suivante drwxrwxrwx</p>

<p>La commande chmod permet de modifier les droits d'accès d'un fichier ou d'un dossier. Attention de ne pas la confondre
  avec la commande chown qui permet de gérer quel utilisateur et quel groupe est propriétaire d'un fichier</p>

  <p>Il n'est pas nécessaire d'être super-utilisateur pour modifier un dossier ou fichier. En revanche, il faut être propriétaire de ce dossier ou fichier.</p>

  <p>Pour utiliser la commande chmod, il faut savoir qu'à chaque lettre correspond un chiffre. Ainsi, r correspond à 4,
  w correspond à 2 et x correspond à 1. On combine maintenant les droits en additionnant les chiffres précédents.</p>
  <p>Ainsi le tableau suivant récapitule les différents droits sous forme de chiffres :</p>

  <table>
    <tr><th>droits</th><th>chiffres correspondants</th></tr>
    <tr><td>---</td><td>0</td></tr>
    <tr><td>r--</td><td>4</td></tr>
    <tr><td>-w-</td><td>2</td></tr>
    <tr><td>--x</td><td>1</td></tr>
    <tr><td>rw-</td><td>6</td></tr>
    <tr><td>wx-</td><td>3</td></tr>
    <tr><td>r-x</td><td>5</td></tr>
    <tr><td>rwx</td><td>7</td></tr>
  </table>

<p>Par exemple 640 représente les droits du propriétaire (6 donc lecture, écriture), les droits du groupe (4 donc lecture),
et les droits des autres utilisateurs (0 donc aucun droit).</p>

  <p>Finalement, pour changer les droits sur le monFichier et être le seul autorisé à le lire et le modifier, il faut exécuter la commande suivante</p>
  <pre><code class="language-svg">chmod 600 monFichier</code></pre>
  <p>Cette commande est la même pour un dossier. Il faut penser à se placer dans le répertoire parent ou préciser une adresse absolue.</p>

  <p>Maintenant la commande ls -l fournit le résultat suivant</p>
  <pre><code class="language-svg">-rw------- 1 [nomUtilisateur] [nomUtilisateur] 0 2019-09-15 21:12 monFichier</code></pre>

  <p>Pour affecter des droits sur un dossier de manière récursive, c'est à dire en affectant tous les fichiers et sous-dossiers qu'il contient,
  il faut utiliser la commande</p>
  <pre><code class="language-svg">chmod -R 600 monFichier</code></pre>
  <p>Cette commande est la même pour un dossier. Il faut penser à se placer dans le répertoire parent ou préciser une adresse absolue.</p>



  <h3>Installation d'un programme, décompression d'une archive</h3>


  <h4>Installation d'un programme avec apt-get</h4>
  
  <p>Il faut généralement mettre à jour le cache des paquets (i.e. télécharger la nouvelle liste des paquets proposés par le dépôt) avant de procéder à l'installation :</p>
  <pre><code class="language-svg">sudo apt-get update
sudo apt-get install monPaquet</code></pre>
  
  <p>Pour obtenir la description d'un paquet :</p>
  <pre><code class="language-svg">sudo apt-cache show nomPaquet</code></pre>
  
 
  <p>Pour mettre à jour tous les paquets, il faut d'abord récupérer la liste des nouveaux paquets afin de pouvoir comparer leurs versions
    à celles présentes dans le système. Cette opération doit être faite régulièrement pour assurer la sécurité du système.</p>
    <pre><code class="language-svg">sudo apt-get update
sudo apt-get upgrade</code></pre>
 

  
  <h4>Commandes pour zipper/dézipper un dossier/fichier .zip</h4>
  
  <p><em>Rappel, </em>compresser un dossier permet de le transformer en un fichier encodé qui occupe suffisamment peu d'espace mémoire 
  pour pouvoir être transmis facilement. Un format classique de compression est le format .ZIP. Le destinataire peut ensuite 
décompresser ce fichier qui détient les clés de décompression, pour obtenir le dossier de départ.</p>

  <p>Pour zipper le dossier monProjet sans changer de nom, il faut ouvrir le Terminal, se placer dans le dossier contenant monProjet puis exécuter :</p>
  <pre><code class="language-svg">zip monProjet</code></pre>

  <p>Le fichier zippé obtenu monProjet.zip a été créé dans le même dossier que monProjet.</p>

  <p>Pour dézipper le fichier monProjet.zip sans changer de nom, il faut ouvrir le Terminal, se placer dans le dossier contenant monProjet.zip puis exécuter :</p>
  <pre><code class="language-svg">unzip monProjet.zip</code></pre>

  <p>Le dossier dézippé obtenu monProjet a été créé dans le même dossier que monProjet.zip</p>

  <p>Pour zipper le dossier monProjet en l'appelant moArchive.zip :</p>
  <pre><code class="language-svg">zip -r moArchive.zip monProjet</code></pre>
  
  <p>Pour dézipper l'archive mon_archive.zip en l'appelant mon_dossier :</p>
  <pre><code class="language-svg">unzip mon_archive.zip -d mon_dossier</code></pre>
  
  
  
  <h4>Commande pour dézipper un fichier .gz</h4>
  
  <p>Il faut se placer dans le dossier contenant monDossier.gz et l'instruction
	suivante va le décompresser à ce même emplacement :</p>
  <pre><code class="language-svg">gunzip monDossier.gz</code></pre>
  
  
  
  <h4>Installation d'un logiciel à partir de .sh</h4>
  
  <p>Un fichier au format .sh est un fichier d'installation qui s'ouvre avec une commande bash. Pour cela, dans le répertoire courant, il faut d'abord
	vérifier l'intégrité de l'installer en utilisant :</p>
  
  <pre><code class="language-svg">sha256sum nomInstaller.sh</code></pre>
  
  <p>puis lancer l'installation à l'aide de :</p>
  
  <pre><code class="language-svg">bash nomInstaller.sh</code></pre>
  

  
  <h4 id="targz">Installation d'un logiciel à partir de .tar.gz</h4>
  
  <p>Un fichier .tar est une archive non compressée. En revanche, un fichier .gz est une compression de fichier.</p>
  <p>Il faut d'abord déplacer le fichier .tar.gz vers /usr/local. Pour cela :</p>
  <pre><code class="language-svg">sudo mv /home/stephane/Téléchargements/nom_fichier.tar.gz /usr/local</code></pre>
  <p>Il faut ensuite se placer dans le répertoire /usr/local</p>
  <pre><code class="language-svg">cd /usr/local</code></pre>
  <p>Puis il faut décompresser le fichier .gz :</p>
  <pre><code class="language-svg">sudo tar xvzf nom_fichier.tar.gz</code></pre>
  
  <p>Finalement, il faut suivre les instructions d'installation dans le ficier README.txt ou le INSTALL</p>
  
  
  
  <!-- installation d'un logiciel avec tar.bz2 -->
  
  <h4 id="tarbz2">Installation d'un logiciel à partir de .tar.bz2</h4>
  
  <p>Il faut d'abord déplacer le fichier .tar.bz2 vers /usr/local. Pour cela :</p>
  <pre><code class="language-svg">sudo mv /home/stephane/Téléchargements/nom_fichier.tar.bz2 /usr/local</code></pre>
  <p>Il faut ensuite se placer dans le répertoire /usr/local</p>
  <pre><code class="language-svg">cd /usr/local</code></pre>
  <p>Puis il faut décompresser le fichier .bz2 :</p>
  <pre><code class="language-svg">sudo tar xfvj nom_fichier.tar.bz2</code></pre>
  
  <p>Finalement, il faut suivre les instructions d'installation dans le ficier README.txt ou le INSTALL</p>
  
  
  
  <!-- installation d'un logiciel à partir de .deb -->
  
  <h4 id="deb">Installation d'un logiciel à partir de .deb</h4>
  
  <p>Un fichier .deb est un package permettant d'installer une application sous les systèmes Linux Debian.</p>
  
  <p>Il faut d'abord déplacer le fichier .tar.bz2 vers /usr/local. Pour cela :</p>
  <pre><code class="language-svg">sudo mv /home/stephane/Téléchargements/nom_fichier.tar.bz2 /usr/local</code></pre>
  <p>Il faut ensuite se placer dans le répertoire /usr/local</p>
  <pre><code class="language-svg">cd /usr/local</code></pre>
  
  <p>Puis il faut exécuter le fichier .deb</p>
  <pre><code class="language-svg">sudo dpkg -i nom_fichier.deb</code></pre>
  

<h4>Désinstallation d'un logiciel</h4>

<p>Pour désinstaller un paquet, on peut utiliser l'instruction suivante :</p>

<pre><code class="language-svg">sudo apt-get remove monPaquet</code></pre>

<p>Pour désinstaller un paquet et ses dépendances devenues inutiles, on utilise</p>

<pre><code class="language-svg">sudo apt-get autoremove monPaquet</code></pre>






<h3>Sécurité sur Linux</h3>

<h4>Nettoyage</h4>

<p>Il est utile d'effectuer un nettoyage régulier de la mémoire et des dépendances à l'aide des instructions 
  suivantes :</p>

<pre><code class="language-svg">sudo apt-get autoclean
sudo apt-get clean
sudo apt-get autoremove</code></pre>





  <!-- ANTIVIRUS -->
  <h4>Antivirus</h4>

  <p>L'antivirus ClamAv est compatible avec Linux et fonctionne en ligne de commande.</p>

  <p>L'installation est détaillée sur la page <a href="https://www.inmotionhosting.com/support/security/install-clamav-on-ubuntu/"> inmotion.hosting</a></p>

  <p>L'installation en ligne de commande s'effectue de la façon suivante :</p>
  <pre><code class="language-svg">sudo apt-get update
sudo apt-get install clamav clamav-daemon -y
sudo systemctl stop clamav-freshclam
sudo freshclam
sudo systemctl start clamav-freshclam</code></pre>

<p>Il est donc nécessaire de stopper le processus de ClamAv avant de mettre à jour la base de données de ClamAv pour ensuite relancer le processus de ClamAv. Cet antivirus s'active en ligne de commande et ne possède pas d'interface graphique. L'icône de ClamAv n'apparaît donc pas dans la liste des applications installées.</p>

  <p>Pour lancer le scan, utiliser les instructions suivantes</p>
<pre><code class="language-svg">clamscan -r /</code></pre>

<p>Le processus de scan est assez long mais peut s'exécuter en toile de fond.</p>






  <!-- mise à niveau système -->

  <h3 id="upgrade">Mise à niveau système</h3>

  <pre><code class="language-svg">sudo apt-get update
sudo apt-get upgrade
sudo apt dist-upgrade
sudo apt-get install update-manager-core
sudo do-release-upgrade
sudo apt-get update</code></pre>






  <!-- CREATION CLE BOOTABLE -->

  <h3 id="bootable">Création d'une clé bootable et installation de Linux</h3>

<p>La création d'une clé bootable ne nécessite pas nécessairement l'utilisation d'un ordinateur tiers. Toutefois, pour La création d'une clé bootable en ligne de commande il est nécessaire de disposer d'un poste tiers Linux. se fait en 3 étapes :</p>
<ul>
<li>télécharger l'image .iso de la version souhaitée de Linux à partir du <a href="https://releases.ubuntu.com/">site de Ubuntu releases</a> (pour la version Ubuntu) à l'aide d'un ordinateur tiers. Il est important de ne connecter qu'une seule clé à l'ordinateur tiers.</li>
<li>partitionner une clé pour qu'elle devienne bootable à l'aide d'un ordinateur tiers, puis placer l'image .iso dans cette clé. Celle-ci devra posséder une capacité de stockage supérieure à 3 Go. Attention, il ne sera plus possible de l'utiliser comme clé de stockage par la suite.</li>
<li>brancher la clé bootable sur l'ordinateur cible qu'on allume en ouvrant le menu boot (souvent F1 ou F2). Il faut ensuite configurer le démarrage sur clé USB, et finalement installer Linux en suivant les instructions.</li>
</ul>

  <p>Le détail de l'étape 2 (création d'une clé bootable en ligne de commande) se trouve ci-dessous :</p>
  <ul>
  	<li>introduire la clé dans l'ordinateur tiers puis identifier le nom de cette clé avec l'instruction <pre><code class="language-svg">lsblk</code></pre> . On doit obtenir un résultat du type sdb ... puis le détail sdb1 ...</li>
  	<li>démonter les partitions de cette clé avec l'instruction <pre><code class="language-svg">sudo umount /dev/sdb1</code></pre> où sdb1 représente la référence de la clé.</li>
  	<li>copier l'image .iso vers la clé USB avec l'instruction <pre><code class="language-svg">sudo dd if=Téléchargements/monImage.iso of=/dev/sdb bs=4M status=progress && sync</code></pre>, où dd permet de copier un disque, sdb est la nouvelle référence de la clé USB, 4M représente la taille, progress permet de voir en temps réel le progrès de la création de la clé et sync force les buffers à se vider sur la clé.</li>
  	<li>il faut ensuite déconnecter puis connecter la clé sur l'ordinateur tiers</li>
  </ul>

{% endblock %}
